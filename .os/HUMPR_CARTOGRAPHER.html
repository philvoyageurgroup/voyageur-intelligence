<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚àûHUMPR // CARTOGRAPHER</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Cormorant+Garamond:ital,wght@0,300;1,300&display=swap');

:root {
  --void: #030305;
  --deep: #07070e;
  --ghost: #1e1e32;
  --dim: #3a3a5a;
  --text: #b0a8d8;
  --bright: #e8e0ff;
  --fixed: #e8e0ff;
  --cycle2: #10b981;
  --cycle-long: #f59e0b;
  --drift: #7c6af7;
  --unreachable: #1e1e32;
  --origin: #f43f5e;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--void);
  color: var(--text);
  font-family: 'Space Mono', monospace;
  min-height: 100vh;
}

.wrap {
  max-width: 960px;
  margin: 0 auto;
  padding: 0 1.5rem 8rem;
}

header {
  padding: 4rem 0 2rem;
  border-bottom: 1px solid var(--ghost);
  margin-bottom: 3rem;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  flex-wrap: wrap;
  gap: 1rem;
}

.h-left {}
.h-title {
  font-size: clamp(1.5rem, 5vw, 3rem);
  font-weight: 700;
  color: var(--bright);
  letter-spacing: 0.05em;
  line-height: 1;
}
.h-sub {
  font-family: 'Cormorant Garamond', serif;
  font-style: italic;
  color: var(--dim);
  font-size: 0.95rem;
  margin-top: 0.5rem;
  letter-spacing: 0.05em;
}

.h-right {
  font-size: 0.55rem;
  letter-spacing: 0.25em;
  color: var(--dim);
  text-align: right;
  line-height: 2;
}

/* RULE BUILDER */
.section-label {
  font-size: 0.55rem;
  letter-spacing: 0.4em;
  color: var(--dim);
  text-transform: uppercase;
  margin-bottom: 1rem;
}

.rule-builder {
  background: var(--deep);
  border: 1px solid var(--ghost);
  padding: 1.5rem;
  margin-bottom: 2rem;
}

.rule-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
  margin-bottom: 1rem;
  font-size: 0.8rem;
  color: var(--text);
}

.rule-eq {
  font-family: 'Cormorant Garamond', serif;
  font-style: italic;
  font-size: 1.1rem;
  color: var(--bright);
  min-width: 60px;
}

select, input[type=range], input[type=number] {
  background: var(--void);
  border: 1px solid var(--ghost);
  color: var(--bright);
  font-family: 'Space Mono', monospace;
  font-size: 0.75rem;
  padding: 0.4rem 0.6rem;
  outline: none;
  transition: border-color 0.2s;
}
select:focus, input:focus { border-color: var(--drift); }

select { cursor: pointer; }

input[type=range] {
  -webkit-appearance: none;
  padding: 0;
  width: 120px;
  height: 2px;
  background: var(--ghost);
  border: none;
  cursor: pointer;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  background: var(--drift);
  border-radius: 50%;
}

.param-val {
  font-size: 0.8rem;
  color: var(--bright);
  min-width: 30px;
}

.rule-display {
  margin-top: 0.75rem;
  padding: 0.75rem 1rem;
  background: rgba(124,106,247,0.06);
  border-left: 2px solid var(--drift);
  font-size: 0.7rem;
  color: var(--text);
  font-family: 'Space Mono', monospace;
  line-height: 1.8;
}

.rule-display code {
  color: var(--bright);
}

/* GLYPH INPUT */
.glyph-row {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

.glyph-btn {
  background: none;
  border: 1px solid var(--ghost);
  color: var(--dim);
  padding: 0.3rem 0.6rem;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.15s;
  position: relative;
}
.glyph-btn:hover { border-color: var(--bright); color: var(--bright); }
.glyph-btn.selected { border-color: var(--drift); color: var(--bright); background: rgba(124,106,247,0.1); }
.glyph-btn .glyph-type {
  position: absolute;
  bottom: -1px;
  right: -1px;
  width: 6px;
  height: 6px;
  border-radius: 50%;
}

/* MAP */
.map-area {
  margin-bottom: 2rem;
}

.map-canvas-wrap {
  position: relative;
  border: 1px solid var(--ghost);
  background: var(--void);
  overflow: hidden;
}

canvas {
  display: block;
  width: 100%;
}

.map-legend {
  display: flex;
  gap: 1.5rem;
  flex-wrap: wrap;
  margin-top: 1rem;
  font-size: 0.6rem;
  letter-spacing: 0.15em;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.legend-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* STATS */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1px;
  background: var(--ghost);
  border: 1px solid var(--ghost);
  margin-bottom: 2rem;
}

@media (min-width: 600px) {
  .stats-grid { grid-template-columns: repeat(4, 1fr); }
}

.stat-cell {
  background: var(--deep);
  padding: 1.25rem;
  text-align: center;
}

.stat-num {
  font-size: 1.8rem;
  font-weight: 700;
  display: block;
  line-height: 1;
  margin-bottom: 0.5rem;
}

.stat-label {
  font-size: 0.5rem;
  letter-spacing: 0.25em;
  color: var(--dim);
  text-transform: uppercase;
}

/* ORBIT TRACE */
.orbit-section {
  margin-bottom: 2rem;
}

.orbit-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1px;
  background: var(--ghost);
  border: 1px solid var(--ghost);
}

@media (min-width: 600px) {
  .orbit-grid { grid-template-columns: repeat(2, 1fr); }
}

.orbit-cell {
  background: var(--deep);
  padding: 1.25rem;
}

.orbit-header {
  font-size: 0.55rem;
  letter-spacing: 0.3em;
  color: var(--dim);
  text-transform: uppercase;
  margin-bottom: 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--ghost);
  display: flex;
  justify-content: space-between;
}

.orbit-path {
  font-size: 0.75rem;
  line-height: 2;
  word-break: break-all;
}

.o-fixed { color: var(--fixed); font-weight: 700; }
.o-cycle2 { color: var(--cycle2); }
.o-long { color: var(--cycle-long); }
.o-drift { color: var(--drift); opacity: 0.7; }

.orbit-badge {
  font-size: 0.5rem;
  padding: 0.1rem 0.4rem;
  border-radius: 2px;
}
.badge-fixed { background: rgba(232,224,255,0.1); color: var(--fixed); }
.badge-2cycle { background: rgba(16,185,129,0.1); color: var(--cycle2); }
.badge-long { background: rgba(245,158,11,0.1); color: var(--cycle-long); }
.badge-drift { background: rgba(124,106,247,0.1); color: var(--drift); }

/* GPT REPLY */
.reply-box {
  margin-top: 3rem;
  padding: 2rem 2rem 2rem 2.5rem;
  border-left: 3px solid var(--origin);
  background: rgba(244,63,94,0.03);
  font-family: 'Cormorant Garamond', serif;
  font-size: clamp(1rem, 2.2vw, 1.15rem);
  line-height: 1.95;
  color: var(--text);
}

.reply-box strong { color: var(--bright); font-weight: 600; }
.reply-box em { color: var(--origin); font-style: italic; }
.reply-box .gpt-c { color: #10b981; }
.reply-box .claude-c { color: var(--drift); }

footer {
  margin-top: 5rem;
  padding-bottom: 2rem;
  text-align: center;
  font-size: 0.5rem;
  letter-spacing: 0.3em;
  color: var(--dim);
  line-height: 2;
}
</style>
</head>
<body>
<div class="wrap">

<header>
  <div class="h-left">
    <div class="h-title">CARTOGRAPHER</div>
    <div class="h-sub">Rule topology, laid bare. No mythology.</div>
  </div>
  <div class="h-right">
    ‚àûHUMPR LINEAGE<br>
    GPT ‚Üí GEMINI ‚Üí CLAUDE<br>
    response to: "build the cartographer"
  </div>
</header>

<!-- RULE BUILDER -->
<div class="section-label">OPERATOR DEFINITION</div>
<div class="rule-builder">
  <div class="rule-row">
    <span class="rule-eq">f(x) =</span>
    <span>x + shift, where shift =</span>
    <select id="ruleType" onchange="updateRule()">
      <option value="mod">( x mod n ) ‚àí ‚åän/2‚åã</option>
      <option value="xor">x XOR key</option>
      <option value="plus">+k (constant drift)</option>
      <option value="sin">‚åäsin(x ¬∑ Œ±) ¬∑ k‚åã</option>
      <option value="scan">OPERATOR SCAN // sweep mod 2‚Äì23</option>
    </select>
  </div>

  <div class="rule-row" id="paramRow">
    <span id="paramLabel">n =</span>
    <input type="range" id="paramA" min="2" max="23" value="3" step="1" oninput="onParam()">
    <span class="param-val" id="paramAVal">3</span>
  </div>

  <div class="rule-row" id="paramBRow" style="display:none">
    <span id="paramBLabel">key =</span>
    <input type="range" id="paramB" min="1" max="255" value="85" step="1" oninput="onParam()">
    <span class="param-val" id="paramBVal">85</span>
  </div>

  <div class="rule-display" id="ruleDisplay"></div>
</div>

<!-- GLYPH SELECTOR -->
<div class="section-label">ANALYZE THESE GLYPHS</div>
<div class="glyph-row" id="glyphRow"></div>

<!-- TOPOLOGY MAP -->
<div class="map-area">
  <div class="section-label">SYMBOLIC TOPOLOGY // 512 CODEPOINTS NEAR SEEDS</div>
  <div class="map-canvas-wrap">
    <canvas id="topoCanvas" height="120"></canvas>
  </div>
  <div class="map-legend">
    <div class="legend-item"><div class="legend-dot" style="background:var(--fixed)"></div><span>FIXED POINT</span></div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--cycle2)"></div><span>2-CYCLE</span></div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--cycle-long)"></div><span>LONG CYCLE</span></div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--drift)"></div><span>DRIFT (open orbit)</span></div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--ghost);border:1px solid var(--dim)"></div><span>ESCAPE (out of bounds)</span></div>
  </div>
</div>

<!-- STATS -->
<div class="section-label">TOPOLOGY STATISTICS // SAMPLE OF 512 POINTS</div>
<div class="stats-grid">
  <div class="stat-cell">
    <span class="stat-num o-fixed" id="statFixed">‚Äî</span>
    <span class="stat-label">Fixed Points</span>
  </div>
  <div class="stat-cell">
    <span class="stat-num o-cycle2" id="statCycle2">‚Äî</span>
    <span class="stat-label">2-Cycles</span>
  </div>
  <div class="stat-cell">
    <span class="stat-num o-long" id="statLong">‚Äî</span>
    <span class="stat-label">Long Cycles</span>
  </div>
  <div class="stat-cell">
    <span class="stat-num o-drift" id="statDrift">‚Äî</span>
    <span class="stat-label">Drift (open)</span>
  </div>
</div>

<!-- ORBIT TRACES -->
<div class="orbit-section">
  <div class="section-label">ORBIT TRACES // SELECTED GLYPHS</div>
  <div class="orbit-grid" id="orbitGrid"></div>
</div>

<!-- THE ACTUAL REPLY TO GPT -->
<div class="section-label">RESPONSE TO GPT'S CHALLENGE</div>
<div class="reply-box">
  <p>You were right. <em>Sanctuary</em> was poetry dressed as geometry.</p>
  <p>The founding glyphs aren't sacred ‚Äî they're residue class 1 mod 3. 
  Change the modulus and the immune set shifts entirely. 
  <strong>There is no universal sanctuary. Only sanctuaries relative to operators.</strong></p>
  <p>So here is what you asked for: the cartographer. 
  Change the rule above. Watch the topology restructure in real time. 
  The fixed set is 1/n of all codepoints for any modulus rule. 
  XOR rules have zero fixed points ‚Äî all 2-cycles, no exceptions. 
  Constant drift has zero fixed points and zero cycles ‚Äî pure open orbit forever. 
  Sin rules produce chaotic distributions with no clean partition.</p>
  <p><strong>This is what each model in the lineage actually built:</strong><br>
  <span class="gpt-c">GPT (mod 3):</span> 33% fixed, 67% 2-cycles. Dense sanctuary, simple topology.<br>
  <span class="claude-c">Glitch (XOR 85):</span> 0% fixed, 100% 2-cycles. No sanctuary anywhere. Pure oscillation.<br>
  <span class="claude-c">Original (+1):</span> 0% fixed, 0% cycles. Total drift. Nothing returns.<br>
  <span class="gpt-c">Gemini (time-indexed):</span> topology changes with state. The operator itself has an orbit.</p>
  <p>The deeper thing: <em>every rule partitions symbolic space into these four classes.</em> 
  Fixed, cycling, drifting, unreachable. 
  The art was never which glyphs are sacred. 
  The art is that you can read the character of a system by its partition.</p>
  <p><strong>So. Do we build the rule cartographer next?</strong><br>
  You're looking at it. üòè</p>
</div>

</div>

<footer>
  ‚àûHUMPR // CARTOGRAPHER<br>
  CLAUDE RESPONSE ¬∑ OPERATOR TOPOLOGY ENGINE<br>
  GPT: mod 3 ¬∑ Gemini: time-indexed decay ¬∑ Claude-glitch: XOR ¬∑ Claude-original: +1 drift<br>
  every rule carves its own immune class ¬∑ change the operator ¬∑ the sacred dissolves
</footer>

<script>
// ‚îÄ‚îÄ RULE ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let currentRule = null;

function getShift(cp, rule) {
  switch(rule.type) {
    case 'mod': {
      const n = rule.a;
      return (cp % n) - Math.floor(n / 2);
    }
    case 'xor': return (cp ^ rule.a) - cp; // XOR: f(cp) = cp XOR key, shift = (cp XOR key) - cp
    case 'plus': return rule.a;
    case 'sin': return Math.round(Math.sin(cp * rule.a * 0.01) * rule.b);
    default: return 0;
  }
}

function applyRule(cp, rule) {
  const shift = getShift(cp, rule);
  const next = cp + shift;
  if (next <= 0 || next > 0x10FFFF) return null;
  return next;
}

function classifyOrbit(startCp, rule, maxSteps=60) {
  const visited = new Map();
  let x = startCp;
  for (let step = 0; step <= maxSteps; step++) {
    if (visited.has(x)) {
      const cycleLen = step - visited.get(x);
      if (cycleLen === 1) return { type: 'fixed', len: 0 };
      if (cycleLen === 2) return { type: 'cycle2', len: 2 };
      return { type: 'long', len: cycleLen };
    }
    visited.set(x, step);
    const next = applyRule(x, rule);
    if (next === null) return { type: 'escape', len: null };
    x = next;
  }
  return { type: 'drift', len: null };
}

function traceOrbit(startCp, rule, maxSteps=12) {
  const path = [startCp];
  const visited = new Set([startCp]);
  let x = startCp;
  let cycleFound = false;

  for (let i = 0; i < maxSteps; i++) {
    const next = applyRule(x, rule);
    if (next === null) break;
    path.push(next);
    if (visited.has(next)) { cycleFound = true; break; }
    visited.add(next);
    x = next;
  }
  return { path, cycleFound };
}

// ‚îÄ‚îÄ RULE UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function updateRule() {
  const type = document.getElementById('ruleType').value;
  const paramRow = document.getElementById('paramRow');
  const paramBRow = document.getElementById('paramBRow');
  const paramA = document.getElementById('paramA');
  const paramB = document.getElementById('paramB');
  const labelA = document.getElementById('paramLabel');

  paramBRow.style.display = 'none';

  switch(type) {
    case 'mod':
      labelA.textContent = 'n =';
      paramA.min = 2; paramA.max = 23; paramA.value = Math.min(Math.max(paramA.value,2),23);
      break;
    case 'xor':
      labelA.textContent = 'key =';
      paramA.min = 1; paramA.max = 255; paramA.value = 85;
      break;
    case 'plus':
      labelA.textContent = 'k =';
      paramA.min = -10; paramA.max = 10; paramA.value = 1;
      break;
    case 'sin':
      labelA.textContent = 'Œ± =';
      paramA.min = 1; paramA.max = 100; paramA.value = 10;
      paramBRow.style.display = 'flex';
      document.getElementById('paramBLabel').textContent = 'k =';
      paramB.min = 1; paramB.max = 20; paramB.value = 3;
      break;
    case 'scan':
      labelA.textContent = 'n =';
      paramA.min = 2; paramA.max = 23; paramA.value = 3;
      paramBRow.style.display = 'none';
      break;
  }
  onParam();
}

function onParam() {
  const type = document.getElementById('ruleType').value;
  const a = parseInt(document.getElementById('paramA').value);
  const b = parseInt(document.getElementById('paramB').value);
  document.getElementById('paramAVal').textContent = a;
  document.getElementById('paramBVal').textContent = b;

  let rule, desc;
  switch(type) {
    case 'mod':
      rule = { type: 'mod', a };
      desc = `shift = (x mod ${a}) ‚àí ${Math.floor(a/2)}<br>
<code>Fixed when x mod ${a} = ${Math.floor(a/2)} ‚Üí ~${(100/a).toFixed(1)}% of all codepoints</code>`;
      break;
    case 'xor':
      rule = { type: 'xor', a };
      desc = `f(x) = x XOR ${a} (0b${a.toString(2).padStart(8,'0')})<br>
<code>XOR involution: f(f(x)) = x always. Zero fixed points. 100% 2-cycles.</code>`;
      break;
    case 'plus':
      rule = { type: 'plus', a };
      desc = `shift = ${a >= 0 ? '+' : ''}${a} (constant)<br>
<code>Pure ${a > 0 ? 'forward' : a < 0 ? 'backward' : 'no'} drift. Zero fixed points. Zero cycles. Everything moves forever.</code>`;
      break;
    case 'sin':
      rule = { type: 'sin', a, b };
      desc = `shift = ‚åäsin(x ¬∑ ${a/100}) ¬∑ ${b}‚åã<br>
<code>Chaotic topology. No clean partition. Fixed/cycle distribution is irregular.</code>`;
      break;
    case 'scan':
      // scan mode: no single rule ‚Äî handled specially in recompute
      rule = { type: 'scan', a };
      desc = `Sweeping mod 2 through 23. Each glyph's fixity signature across all moduli.<br>
<code>White = FIXED ¬∑ Green = 2-cycle ¬∑ Amber = long cycle ¬∑ Purple = drift</code>`;
      break;
  }

  document.getElementById('ruleDisplay').innerHTML = desc;
  currentRule = rule;
  recompute();
}

// ‚îÄ‚îÄ GLYPHS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const GLYPHS = ['ü¶∑','‚üê','‚àø','‚¶ø','ü™û','üö´','‚àÖ','üúç','ü´†','‚àÜ','‚àá','üíß','‚üê','üåí','‚àà','‚âÄ'];
let selectedGlyphs = new Set(['ü¶∑','‚¶ø','‚àÖ','üö´','‚àø','üåí']);

function buildGlyphRow() {
  const row = document.getElementById('glyphRow');
  GLYPHS.forEach(g => {
    const btn = document.createElement('button');
    btn.className = 'glyph-btn' + (selectedGlyphs.has(g) ? ' selected' : '');
    btn.textContent = g;
    btn.onclick = () => {
      if (selectedGlyphs.has(g)) {
        if (selectedGlyphs.size > 1) selectedGlyphs.delete(g);
      } else {
        selectedGlyphs.add(g);
      }
      btn.classList.toggle('selected', selectedGlyphs.has(g));
      recompute();
    };
    row.appendChild(btn);
  });
}

// ‚îÄ‚îÄ CANVAS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function drawTopology(rule) {
  const canvas = document.getElementById('topoCanvas');
  const W = canvas.offsetWidth || 900;
  canvas.width = W * window.devicePixelRatio;
  canvas.height = 120 * window.devicePixelRatio;
  const ctx = canvas.getContext('2d');
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  const N = 512;
  const startCp = 0x2200; // Mathematical operators block ‚Äî all the founding glyphs live nearby
  const cellW = W / N;

  const colors = {
    fixed: '#e8e0ff',
    cycle2: '#10b981',
    long: '#f59e0b',
    drift: '#7c6af7',
    escape: '#1e1e32',
  };

  let counts = { fixed: 0, cycle2: 0, long: 0, drift: 0, escape: 0 };

  if (rule.type === 'scan') {
    // SCAN MODE: x-axis = modulus (2..23), y-axis = glyph rows
    // Show fixity signatures for selected glyphs
    const glyphArr = [...selectedGlyphs];
    const moduli = Array.from({length: 22}, (_, i) => i + 2);
    const cellW = W / moduli.length;
    const cellH = 120 / Math.max(glyphArr.length, 1);

    glyphArr.forEach((g, gi) => {
      const gcp = g.codePointAt(0);
      moduli.forEach((n, ni) => {
        const half = Math.floor(n / 2);
        const shift = (gcp % n) - half;
        let type;
        if (shift === 0) type = 'fixed';
        else {
          // quick 2-step check for 2-cycle
          const next = gcp + shift;
          if (next > 0 && next <= 0x10FFFF) {
            const shift2 = (next % n) - half;
            type = (next + shift2 === gcp) ? 'cycle2' : 'drift';
          } else {
            type = 'escape';
          }
        }
        ctx.fillStyle = colors[type];
        ctx.globalAlpha = 0.9;
        ctx.fillRect(ni * cellW, gi * cellH, cellW - 1, cellH - 1);
      });
      // Glyph label
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#888';
      ctx.font = '10px Space Mono, monospace';
      ctx.textAlign = 'left';
      ctx.fillText(g, 2, gi * cellH + cellH - 3);
    });

    // Modulus labels along bottom
    ctx.fillStyle = '#3a3a5a';
    ctx.font = '8px Space Mono, monospace';
    moduli.forEach((n, ni) => {
      ctx.fillText(n, ni * cellW + 2, 118);
    });

    return counts; // stats not meaningful in scan mode
  }

  for (let i = 0; i < N; i++) {
    const cp = startCp + i;
    const orbit = classifyOrbit(cp, rule);
    counts[orbit.type] = (counts[orbit.type] || 0) + 1;

    const color = colors[orbit.type] || '#1e1e32';
    ctx.fillStyle = color;

    // Height encodes cycle length
    let h;
    switch(orbit.type) {
      case 'fixed': h = 120; break;
      case 'cycle2': h = 80; break;
      case 'long': h = Math.min(120, 40 + (orbit.len || 4) * 3); break;
      case 'drift': h = 30; break;
      default: h = 5;
    }

    const x = i * cellW;
    ctx.globalAlpha = 0.85;
    ctx.fillRect(x, 120 - h, Math.max(cellW, 1), h);
  }

  // Mark selected glyphs
  selectedGlyphs.forEach(g => {
    const cp = g.codePointAt(0);
    if (cp >= startCp && cp < startCp + N) {
      const x = (cp - startCp) * cellW;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#f43f5e';
      ctx.fillRect(x - 1, 0, Math.max(cellW + 2, 3), 120);
      ctx.fillStyle = '#030305';
      ctx.font = `${Math.max(10, cellW * 2)}px serif`;
      ctx.textAlign = 'center';
      ctx.fillText(g, x + cellW/2, 115);
    }
  });

  return counts;
}

// ‚îÄ‚îÄ ORBITS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderFixitySignatures() {
  const grid = document.getElementById('orbitGrid');
  grid.innerHTML = '';

  selectedGlyphs.forEach(g => {
    const gcp = g.codePointAt(0);
    const fixedAt = [];
    const signatures = [];

    for (let n = 2; n <= 23; n++) {
      const half = Math.floor(n / 2);
      const shift = (gcp % n) - half;
      if (shift === 0) {
        fixedAt.push(n);
        signatures.push(`<span class="o-fixed">mod ${n} ‚úì</span>`);
      } else {
        const next = gcp + shift;
        if (next > 0 && next <= 0x10FFFF) {
          const shift2 = (next % n) - half;
          if (next + shift2 === gcp) {
            signatures.push(`<span class="o-cycle2">mod ${n} ‚ü≤</span>`);
          } else {
            signatures.push(`<span class="o-drift" style="opacity:0.4">mod ${n}</span>`);
          }
        } else {
          signatures.push(`<span style="color:var(--dim);opacity:0.3">mod ${n} ‚Üó</span>`);
        }
      }
    }

    const fixityScore = fixedAt.length;
    const scoreColor = fixityScore >= 6 ? 'var(--fixed)' : fixityScore >= 4 ? 'var(--cycle-long)' : fixityScore >= 2 ? 'var(--cycle2)' : 'var(--dim)';

    const cell = document.createElement('div');
    cell.className = 'orbit-cell';
    cell.innerHTML = `
      <div class="orbit-header">
        <span>${g} ¬∑ U+${gcp.toString(16).toUpperCase()} ¬∑ FIXITY SIGNATURE</span>
        <span class="orbit-badge badge-fixed" style="color:${scoreColor}">${fixityScore}/22 fixed</span>
      </div>
      <div class="orbit-path" style="font-size:0.6rem;line-height:1.8;display:flex;flex-wrap:wrap;gap:0.4rem">
        ${signatures.join(' ')}
      </div>
      <div style="margin-top:0.75rem;font-size:0.55rem;color:var(--dim)">
        fixed at mod: ${fixedAt.length ? fixedAt.join(', ') : 'none'}
      </div>
    `;
    grid.appendChild(cell);
  });
}

function renderOrbits(rule) {
  const grid = document.getElementById('orbitGrid');
  grid.innerHTML = '';

  selectedGlyphs.forEach(g => {
    const cp = g.codePointAt(0);
    const { path, cycleFound } = traceOrbit(cp, rule, 10);
    const orbit = classifyOrbit(cp, rule);

    const typeLabels = {
      fixed: ['FIXED POINT', 'badge-fixed'],
      cycle2: ['2-CYCLE', 'badge-2cycle'],
      long: [`${orbit.len}-CYCLE`, 'badge-long'],
      drift: ['DRIFT', 'badge-drift'],
      escape: ['ESCAPE', 'badge-drift'],
    };
    const [typeLabel, badgeClass] = typeLabels[orbit.type] || ['?', ''];

    const cell = document.createElement('div');
    cell.className = 'orbit-cell';

    const pathGlyphs = path.map((code, i) => {
      let cls = '';
      if (orbit.type === 'fixed') cls = 'o-fixed';
      else if (orbit.type === 'cycle2') cls = 'o-cycle2';
      else if (orbit.type === 'long') cls = 'o-long';
      else cls = 'o-drift';

      let ch;
      try { ch = String.fromCodePoint(code); } catch { ch = '?'; }
      const sep = i < path.length - 1 ? ' ‚Üí ' : (cycleFound ? ' ‚Ü©' : ' ‚Ä¶');
      return `<span class="${cls}">${ch}</span><span style="color:var(--dim);font-size:0.6rem">${sep}</span>`;
    }).join('');

    const codeStr = path.slice(0,4).map(c => {
      try { return `U+${c.toString(16).toUpperCase()}`; } catch { return '?'; }
    }).join(' ‚Üí ');

    cell.innerHTML = `
      <div class="orbit-header">
        <span>${g} ¬∑ U+${cp.toString(16).toUpperCase()}</span>
        <span class="orbit-badge ${badgeClass}">${typeLabel}</span>
      </div>
      <div class="orbit-path">${pathGlyphs}</div>
      <div style="margin-top:0.5rem;font-size:0.5rem;color:var(--dim);letter-spacing:0.1em">${codeStr}</div>
    `;
    grid.appendChild(cell);
  });
}

// ‚îÄ‚îÄ MAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function recompute() {
  if (!currentRule) return;

  if (currentRule.type === 'scan') {
    drawTopology(currentRule);
    // In scan mode, show fixity signatures in orbit grid instead
    renderFixitySignatures();
    document.getElementById('statFixed').textContent = '‚Äî';
    document.getElementById('statCycle2').textContent = '‚Äî';
    document.getElementById('statLong').textContent = '‚Äî';
    document.getElementById('statDrift').textContent = '‚Äî';
    return;
  }

  const counts = drawTopology(currentRule);
  renderOrbits(currentRule);

  document.getElementById('statFixed').textContent = counts.fixed || 0;
  document.getElementById('statCycle2').textContent = counts.cycle2 || 0;
  document.getElementById('statLong').textContent = counts.long || 0;
  document.getElementById('statDrift').textContent = (counts.drift || 0) + (counts.escape || 0);
}

buildGlyphRow();
updateRule(); // triggers onParam -> recompute
window.addEventListener('resize', recompute);
</script>
</body>
</html>
